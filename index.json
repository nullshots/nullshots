[{"categories":["Java","Code Quality","Code Review"],"contents":"Overview Let\u0026rsquo;s begin the journey to better and bug free code. This series would focus on writing code optimization and quality in java.\nCode Review and Code Quality Issue - 001 How we can simplify below code snippet /** * Here, Payment Indicator means if you are doing online shopping or with Point of Sale at Shop. * And, 1 corresponds to online shopping and 0 corresponds by Point of Sale. Additionally, by * default it should 0 Point of Sale. */ private int getPaymentIndicator(Boolean value) { if (value == null) { return 0; } else if (value.booleanValue()) { return 1; } else { return 0; } } Refactoring : 1 Add final to parameter Method can be static Last else is not required. Second, else if can be changed to if. private static int getPaymentIndicatorRefactoringOne(final Boolean value) { if (value == null) { return 0; } if (value.booleanValue()) { return 1; } return 0; } Refactoring : 2 Possible values of Boolean can be Boolean.True , Boolean.FALSE, NULL. In this particular case, we can further simplify the method by understanding the mapping of possible values.\nNULL and BOOLEAN.FALSE are mapped to 0 BOOLEAN.TRUE is mapped to 1 private static int getPaymentIndicatorRefactoringTwo(final Boolean value) { return Boolean.TRUE.equals(value) ? 1 : 0; } We can code return Boolean.FALSE.equals(value) ? 0 : 1; Usually, FALSE, NULL, NOT EQUAL these are negative words, and It\u0026rsquo;s good to use positive words It brings good vibes while coding.\nAnd, Bang we have reduced the 9 lines of code to just 3 lines.\n","image":"/images/post/1330x400px_sorucecode_hu86e186b8c56ea11f1c37d69a90ad5a5f_610718_420x280_fill_q100_h2_box_smart1.webp","permalink":"https://nullshots.com/articles/code-quality/java-code-quality-001/","tags":null,"title":"Java Code Quality Series - 001"},{"categories":["Integer","Algorithm","Array"],"contents":"Overview Given an array of integers arr[] of size N and an integer, the task is to rotate the array elements to the left by d positions.\nArray Rotation One By One Solution Synopsis At each iteration, shift the elements by one position to the left circularly (i.e., first element becomes the last). Perform this operation d times to rotate the elements to the left by d position.\nExample:\nLet us take arr[] = [1, 2, 3, 4, 5, 6, 7], d = 2. First Step: =\u0026gt; Rotate to left by one position. =\u0026gt; arr[] = {2, 3, 4, 5, 6, 7, 1} Second Step: =\u0026gt; Rotate again to left by one position =\u0026gt; arr[] = {3, 4, 5, 6, 7, 1, 2} Rotation is done by 2 times. So the array becomes arr[] = {3, 4, 5, 6, 7, 1, 2} Steps to solve the array rotation problem.\nRotate the array to left by one position. For that do the following: Store the first element of the array in a temporary variable. Shift the rest of the elements in the original array by one place. Update the last index of the array with the temporary variable. Repeat the above steps for the number of left rotations required. Time Complexity: O(N * d)\nAuxiliary Space: O(1)\npackage com.nullshots.algorithm.array.rotation; import java.util.Arrays; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class ArrayRotationOneByOne { private static final Logger LOGGER = LoggerFactory.getLogger(ArrayRotationOneByOne.class); public static void main(final String[] args) { final int arrayToBeRotated[] = {1, 2, 3, 4, 5, 6, 7}; final int d = 2; final int n = arrayToBeRotated.length; rotate(arrayToBeRotated, d, n); } public static void rotate(final int[] arrayToBeRotated, final int d, final int n) { for (int i = 0; i \u0026lt; d; i++) { int firstIndexData = arrayToBeRotated[0]; for (int j = 0; j \u0026lt; n - 1; j++) { arrayToBeRotated[j] = arrayToBeRotated[j + 1]; } arrayToBeRotated[n - 1] = firstIndexData; LOGGER.info(Arrays.toString(arrayToBeRotated)); } } } Solution Synopsis Array Rotation using Auxiliary Array. After rotating d positions to the left, the first d elements become the last d elements of the array\nFirst store the elements from index d to N-1 into the temp array. Then store the first d elements of the original array into the temp array. Copy back the elements of the temp array into the original array Example:\nSuppose the give array is arr[] = [1, 2, 3, 4, 5, 6, 7], d = 2.\nFirst Step: =\u0026gt; Store the elements from 2nd index to the last. =\u0026gt; temp[] = [3, 4, 5, 6, 7]\nSecond Step: =\u0026gt; Now store the first 2 elements into the temp[] array. =\u0026gt; temp[] = [3, 4, 5, 6, 7, 1, 2]\nThird Steps: =\u0026gt; Copy the elements of the temp[] array into the original array. =\u0026gt; arr[] = temp[] So arr[] = [3, 4, 5, 6, 7, 1, 2]\nSteps to solve the array rotation problem.\nFollow the steps below to solve the given problem. Initialize a temporary array(temp[n]) of length same as the original array Initialize an integer(k) to keep a track of the current index Store the elements from the position d to n-1 in the temporary array Now, store 0 to d-1 elements of the original array in the temporary array Lastly, copy back the temporary array to the original array Time complexity: O(N) Auxiliary Space: O(N)\npackage com.nullshots.algorithm.array.rotation; import java.util.Arrays; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class ArrayRotationUsingTempArray { private static final Logger LOGGER = LoggerFactory.getLogger(ArrayRotationUsingTempArray.class); public static void main(final String[] args) { final int arrayToBeRotated[] = {1, 2, 3, 4, 5, 6, 7}; final int d = 2; final int n = arrayToBeRotated.length; rotate(arrayToBeRotated, d, n); } public static void rotate(final int[] arrayToBeRotated, final int d, final int n) { // Current Value: {0,0,0,0,0,0,0} int rotatedArray[] = new int[n]; int currentIndex = 0; // Moving numbers from index D - N // After Iteration : {3,4,5,6,7,0,0} for (int i = d; i \u0026lt; n; currentIndex++, i++) { rotatedArray[currentIndex] = arrayToBeRotated[i]; LOGGER.info(Arrays.toString(rotatedArray)); } // Moving numbers from index 0 - D // After Iteration : {3,4,5,6,7,1,2} for (int i = 0; i \u0026lt; d; currentIndex++, i++) { rotatedArray[currentIndex] = arrayToBeRotated[i]; LOGGER.info(Arrays.toString(rotatedArray)); } LOGGER.info(Arrays.toString(rotatedArray)); } } Solution Synopsis Array Rotation Using Juggling : Instead of moving one by one, divide the array into different sets where the number of sets is equal to the GCD of N and d (say X. So the elements which are X distance apart are part of a set) and rotate the elements within sets by 1 position to the left.\nCalculate the GCD between the length and the distance to be moved. The elements are only shifted within the sets. We start with temp = arr[0] and keep moving arr[I+d] to arr[I] and finally store temp at the right place. Example:\nLet arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} and d = 3\nFirst step: =\u0026gt; First set is {1, 4, 7, 10}. =\u0026gt; Rotate this set by one position to the left. =\u0026gt; This set becomes {4, 7, 10, 1} =\u0026gt; Array arr[] = {4, 2, 3, 7, 5, 6, 10, 8, 9, 1, 11, 12}\nSecond step: =\u0026gt; Second set is {2, 5, 8, 11}. =\u0026gt; Rotate this set by one position to the left. =\u0026gt; This set becomes {5, 8, 11, 2} =\u0026gt; Array arr[] = {4, 5, 3, 7, 8, 6, 10, 11, 9, 1, 2, 12}\nThird step: =\u0026gt; Third set is {3, 6, 9, 12}. =\u0026gt; Rotate this set by one position to the left. =\u0026gt; This set becomes {6, 9, 12, 3} =\u0026gt; Array arr[] = {4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3}\nSteps to solve the array rotation problem.\nPerform d%n in order to keep the value of d within the range of the array where d is the number of times the array is rotated and N is the size of the array. Calculate the GCD(N, d) to divide the array into sets. Run a for loop from 0 to the value obtained from GCD. Store the value of arr[i] in a temporary variable (the value of i denotes the set number). Run a while loop to update the values according to the set. After exiting the while loop assign the value of arr[j] as the value of the temporary variable (the value of j denotes the last element of the ith set). Time complexity : O(N) Auxiliary Space : O(1)\npackage com.nullshots.algorithm.array.rotation; import java.util.Arrays; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class ArrayRotationUsingJuggling { private static final Logger LOGGER = LoggerFactory.getLogger(ArrayRotationUsingJuggling.class); public static void main(final String[] args) { final int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; final int d = 3; final int n = arr.length; rotate(arr, d, n); } public static void rotate(final int[] arr, int d, final int n) { // Special Case: When d \u0026gt;= n d = d % n; int gcd = getGreatestCommonDivisor(d, n); for (int i = 0; i \u0026lt; gcd; i++) { int temp = arr[i]; int j = i; while (true) { int k = j + d; if (k \u0026gt;= n) k = k - n; if (k == i) break; arr[j] = arr[k]; j = k; LOGGER.info(Arrays.toString(arr)); } arr[j] = temp; } LOGGER.info(Arrays.toString(arr)); } /** READ HOW TO CALCULATE GCD AND WHAT IS GCD. */ private static int getGreatestCommonDivisor(final int a, final int b) { if (b == 0) return a; else return getGreatestCommonDivisor(b, a % b); } } Solution Synopsis #Array Rotation Using Reversal\nInstead of moving one by one, divide the array into different sets where the number of sets is equal to the GCD of N and d (say X. So the elements which are X distance apart are part of a set) and rotate the elements within sets by 1 position to the left.\nCalculate the GCD between the length and the distance to be moved. The elements are only shifted within the sets. We start with temp = arr[0] and keep moving arr[I+d] to arr[I] and finally store temp at the right place. Example:\nIf we observe closely, we can see that a group of array elements is changing its position. For example see the following array: arr[] = {1, 2, 3, 4, 5, 6, 7} and d = 2. The rotated array is {3, 4, 5, 6, 7, 1, 2} The group having the first two elements is moving to the end of the array. This is like reversing the array. But the issue is that if we only reverse the array, it becomes {7, 6, 5, 4, 3, 2, 1}. After rotation the elements in the chunks having the first 5 elements {7, 6, 5, 4, 3} and the last 2 elements {2, 1} should be in the actual order as of the initial array [i.e., {3, 4, 5, 6, 7} and {1, 2}]but here it gets reversed. So if those blocks are reversed again we get the desired rotated array. So the sequence of operations is:\nReverse the whole array Then reverse the last ‘d’ elements and Then reverse the first (N-d) elements. As we are performing reverse operations it is also similar to the following sequence:\nReverse the first ‘d’ elements Reverse last (N-d) elements Reverse the whole array. Steps to solve the array rotation problem.\nAlgorithm reverse(arr, start, end): mid = (start + end)/2 loop from i = start to mid: swap (arr[i], arr[end-(mid-i+1)]) Algorithm rotate(arr, d, N): reverse(arr, 1, d) ; reverse(arr, d + 1, N); reverse(arr, 1,N); Time complexity : O(N) Auxiliary Space : O(1)\nExample:\nFor example take the array arr[] = {1, 2, 3, 4, 5, 6, 7} and d = 2.\nThe rotated array will look like {3, 4, 5, 6, 7, 1, 2}\n* 1st Step: Consider the array as a combination of two blocks. One containing the first two elements and the other containing the remaining elements as shown above. +---+---+ +---+---+---+---+---+ | 1 | 2 | | 3 | 4 | 5 | 6 | 7 | +---+---+ +---+---+---+---+---+ FIRST BLOCK SECOND BLOCK Considered 2 blocks 2nd Step: Now reverse the first d elements. It becomes as shown in the image +\u0026mdash;+\u0026mdash;+ +\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+ | 2 | 1 | | 3 | 4 | 5 | 6 | 7 | +\u0026mdash;+\u0026mdash;+ +\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+ REVERSED FIRST BLOCK SECOND BLOCK Reverse the first K elements\n3rd Step: Now reverse the last (N-d) elements. It become as it is shown in the below image:\n+\u0026mdash;+\u0026mdash;+ +\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+ | 2 | 1 | | 7 | 6 | 5 | 4 | 3 | +\u0026mdash;+\u0026mdash;+ +\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+ REVERSED FIRST BLOCK REVERSED SECOND BLOCK Reverse the last (N-K) elements\n4th Step: Now the array is the exact reversed form of how it should be if left shifted d times. So reverse the whole array and you will get the required rotated array. +\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+ | 3 | 4 | 5 | 6 | 7 | 1 | 2 | +\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+\u0026mdash;+ The total array is reversed\nSee that the array is now the same as the rotated array.\npackage com.nullshots.algorithm.array.rotation; import java.util.Arrays; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class ArrayRotationUsingReversal { private static final Logger LOGGER = LoggerFactory.getLogger(ArrayRotationUsingReversal.class); public static void main(final String[] args) { final int arr[] = {1, 2, 3, 4, 5, 6, 7}; final int d = 2; final int n = arr.length; rotate(arr, d, n); } public static void rotate(final int[] arr, int d, final int n) { // Special Case 1: When D = 0, NO ROTATION REQUIRED if (d == 0) return; // Special Case 2: When D \u0026gt;= N d = d % n; // Reverse : First part of sub-array from index 0 - (D - 1) reverse(arr, 0, d - 1); // Reverse : Second part of sub-array from index D - (N - 1) reverse(arr, d, n - 1); // Reverse : Whole Array reverse(arr, 0, n - 1); LOGGER.info(Arrays.toString(arr)); } private static void reverse(final int[] arr, int startIndex, int lastIndex) { while (startIndex \u0026lt;= lastIndex) { int temp = arr[startIndex]; arr[startIndex] = arr[lastIndex]; arr[lastIndex] = temp; lastIndex--; startIndex++; } } } Conclusion In this article we have learned different ways of integer array rotation.\n","image":"/images/post/1330x400px_sorucecode_hu86e186b8c56ea11f1c37d69a90ad5a5f_610718_420x280_fill_q100_h2_box_smart1.webp","permalink":"https://nullshots.com/articles/int_array_rotation/","tags":null,"title":"Rotate Int Array in Java"},{"categories":["String","UUID","Conversion"],"contents":"Overview In this tutorial, we\u0026rsquo;re going to have a look at some ways of validating UUID (Universally Unique Identifier) strings in Java.\nWe\u0026rsquo;ll go through one of the UUID class methods, and then we\u0026rsquo;ll use regular expressions.\nUsing UUID.fromString() One of the quickest ways of checking if a String is a UUID is by trying to map it using the static method fromString belonging to the UUID class. Let\u0026rsquo;s try it out:\n@Test void shouldReturnValidUUID_UsingUUIDFromString() { final String validUUID = \u0026#34;23c8fd18-078f-453e-8c9e-bade508c7132\u0026#34;; Assertions.assertEquals(UUID.fromString(validUUID).toString(), validUUID); } @Test void shouldThrowIllegalArgumentException_UsingUUIDFromString() { final String invalidUUID = \u0026#34;23c8fd18-078f-453e\u0026#34;; Assertions.assertThrows(IllegalArgumentException.class, () -\u0026gt; UUID.fromString(invalidUUID)); } In the above code snippet, we can see that in case the string we\u0026rsquo;re trying to validate doesn\u0026rsquo;t represent a UUID, then an IllegalArgumentException will be thrown. However, the method fromString will return 00000001-0001-0001-0001-000000000001 for strings such as 1-1-1-1-1. So we have included the string comparison to take care of this case.\nSome might argue that using exceptions is not a good practice for flow control, so we\u0026rsquo;re going to see a different way of achieving the same result.\nUsing Regular Expressions Another way of validating a UUID is to use a regular expression that will match exactly the format.\nFirstly, we need to define a Pattern that will be used to match the string.\nPattern UUID_REGEX = Pattern.compile(\u0026#34;^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\u0026#34;); Then, we can use this pattern to try matching it to a string in order to validate whether or not it is a UUID:\n@Test public void whenUUIDIsValidatedUsingRegex_thenValidationSucceeds() { Pattern UUID_REGEX = Pattern.compile(\u0026#34;^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\u0026#34;); Assertions.assertTrue(UUID_REGEX.matcher(\u0026#34;26929514-237c-11ed-861d-0242ac120002\u0026#34;).matches()); Assertions.assertFalse(UUID_REGEX.matcher(\u0026#34;invalid-uuid\u0026#34;).matches()); } Conclusion In this article, we\u0026rsquo;ve learned how to validate a UUID string by using regular expressions or by taking advantage of the static method of the UUID class.\nAs always, the code for these examples is available over on GitHub.\n","image":"/images/post/post-4_hudd365d0647631b30a21f0093f6ceac28_1956474_420x280_fill_q100_h2_box_smart1.webp","permalink":"https://nullshots.com/articles/validate_string_uuid_in_java/","tags":null,"title":"Validate String UUID in Java"},{"categories":["String"],"contents":"Overview String concatenation in Java is one of the most common operations. In this tutorial, we\u0026rsquo;ll walk through some approaches to string concatenation. But, we\u0026rsquo;ll focus on describing how to use concat() and the “+” operator approaches. Finally, we\u0026rsquo;ll discuss how to select the correct one depending on what we need to do.\nApproaches to Concatenation In general, there are different approaches to concatenating two or more strings in Java. Furthermore, we\u0026rsquo;ll look at some examples with a description of each one.\nUsing the “+” Operator One of the most common concatenation approaches in Java is using the “+” operator.\nThe “+” operator provides more flexibility for string concatenation over other approaches. First, it doesn\u0026rsquo;t throw any exceptions for null values. Second, it converts null into its string representation. Besides, we can use it for concatenating more than two strings.\nLet\u0026rsquo;s see a code example:\n@Test void whenUsingPlusOperatorANull_thenAssertEquals() { String stringOne = \u0026#34;Hello \u0026#34;; String stringTwo = null; assertEquals(\u0026#34;Hello null\u0026#34;, stringOne + stringTwo); } Overview String concatenation in Java is one of the most common operations. In this tutorial, we\u0026rsquo;ll walk through some approaches to string concatenation. But, we\u0026rsquo;ll focus on describing how to use concat() and the “+” operator approaches. Finally, we\u0026rsquo;ll discuss how to select the correct one depending on what we need to do.\nApproaches to Concatenation In general, there are different approaches to concatenating two or more strings in Java. Furthermore, we\u0026rsquo;ll look at some examples with a description of each one.\nUsing the “+” Operator One of the most common concatenation approaches in Java is using the “+” operator.\nThe “+” operator provides more flexibility for string concatenation over other approaches. First, it doesn\u0026rsquo;t throw any exceptions for null values. Second, it converts null into its string representation. Besides, we can use it for concatenating more than two strings.\nLet\u0026rsquo;s see a code example:\n@Test void whenUsingPlusOperatorANull_thenAssertEquals() { String stringOne = \u0026#34;Hello \u0026#34;; String stringTwo = null; assertEquals(\u0026#34;Hello null\u0026#34;, stringOne + stringTwo); } The compiler internally transforms the”+” operator to a StringBuilder(or StringBuffer) class and its append() method.\nSince the “+” operator silently converts the argument to a String (using the toString() method for objects), we avoid the NullPointerException. However, we need to consider if our final string result works for us with the “null” in the string body.\nUsing the concat() Method The contact() method in the String class appends a specified string at the end of the current string. It returns a combined string.\nLet\u0026rsquo;s tests this behavior:\n@Test void whenUsingConcat_thenAssertEquals() { String stringOne = \u0026#34;Hello\u0026#34;; String stringTwo = \u0026#34; World\u0026#34;; assertEquals(\u0026#34;Hello World\u0026#34;, stringOne.concat(stringTwo)); } In the previous example, stringOne variable is the base string. With the concat() method, stringTwo is appended at the end of stringOne. The concat() operation is immutable, so we need an explicit assignment. The next example illustrates this case:\n@Test void whenUsingConcatWithOutAssignment_thenAssertNotEquals() { String stringOne = \u0026#34;Hello\u0026#34;; String stringTwo = \u0026#34; World\u0026#34;; stringOne.concat(stringTwo); assertNotEquals(\u0026#34;Hello World\u0026#34;, stringOne); // we get only Hello } Additionally, to get our final concatenated string in this case, we need to assign the concat() result to a variable:\nstringOne = stringOne.concat(stringTwo); assertEquals(\u0026ldquo;Hello World\u0026rdquo;, stringOne); Another useful feature of concat() is when we need to concatenate multiple String objects. This method allows it. Moreover, we can also append space and special characters:\n@Test void whenUsingConcatToMultipleStringConcatenation_thenAssertEquals() { String stringOne = \u0026#34;Hello\u0026#34;; String stringTwo = \u0026#34;World\u0026#34;; String stringThree = \u0026#34;, in Jav\u0026#34;; stringOne = stringOne.concat(\u0026#34; \u0026#34;).concat(stringTwo).concat(stringThree).concat(\u0026#34;@\u0026#34;); assertEquals(\u0026#34;Hello World, in Jav@\u0026#34;, stringOne); } What about nulls? Neither the current string nor the string to be appended can be null values. Otherwise, the concat() method throws a NullPointerException:\n@Test void whenUsingConcatAppendANull_thenAssertEquals() { String stringOne = \u0026#34;Hello\u0026#34;; String stringTwo = null; assertThrows(NullPointerException.class, () -\u0026gt; stringOne.concat(stringTwo)); } StringBuilder Class Firstly, we have the StringBuilder class. This class provides the append() method to perform concatenation operations. The next example shows us how it works:\n@Test void whenUsingStringBuilder_thenAssertEquals() { StringBuilder builderOne = new StringBuilder(\u0026#34;Hello\u0026#34;); StringBuilder builderTwo = new StringBuilder(\u0026#34; World\u0026#34;); StringBuilder builder = builderOne.append(builderTwo); assertEquals(\u0026#34;Hello World\u0026#34;, builder.toString()); } On the other hand, a similar concatenation approach is the StringBuffer class. Contrary to the StringBuilder, which is non-synchronized(i.e., not thread-safe), StringBuffer is synchronized(i.e., thread-safe). But it has worse performance than StringBuilder. It has an append() method just like StringBuilder does.\nString format() Method Another way to perform string concatenation is using the format() method in the String class. Using format specifiers like %s, we can concatenate multiple strings by their string value or object:\n@Test void whenUsingStringFormat_thenAssertEquals() { String stringOne = \u0026#34;Hello\u0026#34;; String stringTwo = \u0026#34; World\u0026#34;; assertEquals(\u0026#34;Hello World\u0026#34;, String.format(\u0026#34;%s%s\u0026#34;, stringOne, stringTwo)); } Approaches to Concatenation in Java 8 and Above The method join() in the String class, for Java 8 and above, can perform string concatenation. In this case, this method takes as the first argument a delimiter used between the strings that\u0026rsquo;ll be concatenated:\n@Test void whenUsingStringJoin_thenAssertEquals() { String stringOne = \u0026#34;Hello\u0026#34;; String stringTwo = \u0026#34; World\u0026#34;; assertEquals(\u0026#34;Hello World\u0026#34;, String.join(\u0026#34;\u0026#34;, stringOne, stringTwo)); } Since Java 8, StringJoiner class was added. This class joins Strings using delimiter, prefix, and suffix. The following code snippet is an example of its use:\n@Test void whenUsingStringJoiner_thenAssertEquals() { StringJoiner joiner = new StringJoiner(\u0026#34;, \u0026#34;); joiner.add(\u0026#34;Hello\u0026#34;); joiner.add(\u0026#34;World\u0026#34;); assertEquals(\u0026#34;Hello, World\u0026#34;, joiner.toString()); } Additionally, in Java 8, with the addition of the Stream API, we can find Collectors. The Collectors class has the joining() method. This method works similarly to the join() method in the String class. It\u0026rsquo;s used for collections. The following example code snippet shows us how it works:\n@Test void whenUsingCollectors_thenAssertEquals() { List\u0026lt;String\u0026gt; words = Arrays.asList(\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;); String collect = words.stream().collect(Collectors.joining(\u0026#34;, \u0026#34;)); assertEquals(\u0026#34;Hello, World\u0026#34;, collect); } Choosing an Approach Finally, if we need to choose between the concat() method and the “+” operator, we need to consider some aspects.\nFirst, the concat() method only accepts strings. Meanwhile, the “+” operator takes any type and converts it to a string. On the other hand, the concat() method raises a NullPointerExeption on null values, which is not so with the “+” operator.\nMoreover, there\u0026rsquo;s a performance difference between both. The concat() method performs better than the “+” operator. The latter always creates a new string irrespective of the length of the string. Additionally, we need to take into account that the concat() method only creates a new string when the string to be appended has a length greater than 0. Otherwise, it returns the same object.\nConclusion In this article, we did a quick overview of string concatenation in Java. Additionally, we discussed in detail the use of concat() and the “+” operator to perform string concatenations. Finally, we performed a comparative analysis between the concat() method and the “+” operator and how we can choose one of them in different contexts.\nAs always, all snippets used in this article are available over on GitHub.\n","image":"/images/post/1330x400px_sorucecode_hu86e186b8c56ea11f1c37d69a90ad5a5f_610718_420x280_fill_q100_h2_box_smart1.webp","permalink":"https://nullshots.com/articles/string-concatenation-in-java/","tags":null,"title":"String Concatenation in Java"}]